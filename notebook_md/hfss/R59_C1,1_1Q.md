# Import Modules

```python
%reload_ext autoreload
%autoreload 2
from collections import OrderedDict

import numpy as np

from qiskit_metal import designs, MetalGUI, Dict
from qiskit_metal.qlibrary.sample_shapes.rectangle import Rectangle
from qiskit_metal.qlibrary.sample_shapes.rectangle_hollow import RectangleHollow
from qiskit_metal.qlibrary.tlines.meandered import RouteMeander
from qiskit_metal.qlibrary.tlines.pathfinder import RoutePathfinder
from qiskit_metal.qlibrary.tlines.straight_path import RouteStraight
from qiskit_metal.qlibrary.terminations.short_to_ground import ShortToGround
from qiskit_metal.qlibrary.terminations.launchpad_wb_driven import (
    LaunchpadWirebondDriven,
)
from qiskit_metal.analyses.quantization import EPRanalysis
from qiskit_metal.analyses.simulation import ScatteringImpedanceSim
from qiskit_metal.analyses.quantization import LOManalysis

from zcu_tools.notebook.hfss.fillet_q import Fillet_Qubit
from zcu_tools.notebook.hfss.round_tee import Round_Tee
import zcu_tools.simulate.equation as zeq
```

# Circuit design

```python
project_name = "Fluxonium2D_R59_1Q"

design = designs.DesignPlanar()
gui = MetalGUI(design)
design.overwrite_enabled = True
design.chips.main.size.size_x = 10.000
design.chips.main.size.size_y = 10.000
design.chips.main.size.size_z = -0.650
design.chips.main.material = "sapphire"
design.variables.cpw_width = 0.015
design.variables.cpw_gap = 0.009
var = design.variables
cpw_width, cpw_gap = var.cpw_width, var.cpw_gap
print(var)
```

## Qubit

```python
arm_length = 0.100
pad_width = 0.130
pad_height = 0.090

Q1 = Fillet_Qubit(
    design,
    "Q1",
    dict(
        pos_x=0,
        pos_y=0,
        orientation=0,
        pad_gap=0.030,
        arm_width=0.008,
        arm_length=arm_length,
        arm_fillet=0.020,
        pad_width=pad_width,
        pad_height=pad_height,
        pad_fillet=0.050,
        pocket_width=0.350,
        pocket_height=0.550,
        pocket_fillet=0.050,
        layer="1",
        hfss_inductance="10nH",
    ),
)
gui.rebuild()
gui.autoscale()
gui.screenshot()
```

## Resonator & Transmission line

```python
x_TL, y_TL = 1.2, 2.0
TL_width, TL_gap = 0.020, 0.012

port_L = LaunchpadWirebondDriven(
    design,
    "port_L",
    options=dict(
        pad_width=0.5,
        pad_height=0.25,
        pad_gap=0.2,
        taper_height=0.5,
        pos_x=-x_TL,
        pos_y=y_TL,
        orientation="  0",
        lead_length=0.05,
        trace_width=TL_width,
        trace_gap=TL_gap,
    ),
)
port_R = LaunchpadWirebondDriven(
    design,
    "port_R",
    options=dict(
        pad_width=0.5,
        pad_height=0.25,
        pad_gap=0.2,
        taper_height=0.5,
        pos_x=x_TL,
        pos_y=y_TL,
        orientation="180",
        lead_length=0.05,
        trace_width=TL_width,
        trace_gap=TL_gap,
    ),
)
TL = RouteStraight(
    design,
    "TL",
    dict(
        pin_inputs=dict(
            start_pin=dict(component="port_L", pin="tie"),
            end_pin=dict(component="port_R", pin="tie"),
        ),
        trace_width=TL_width,
        trace_gap=TL_gap,
        hfss_wire_bonds=True,
    ),
)

res_width, res_gap = 0.015, 0.009

R1_len = 5.0238
spacing, fillet = 0.300, 0.050  # fillet=1.5*(res_width+res_gap*2)
l_couple, grd_gap = 0.4510, 0.004
R_ext, shift_x, shift_y = 0.200, 0, 0.250
tee_width, tee_length, tee_fillet = 0.016, 0.100, 0.005

Tee = Round_Tee(
    design,
    "Tee",
    dict(
        ref_qc=Q1,
        rel_ori="90",
        shift_x=shift_x,
        shift_y=shift_y,
        cpw_width=res_width,
        cpw_gap=res_gap,
        ext_len=R_ext,
        tee_width=tee_width,
        tee_length=tee_length,
        tee_fillet=tee_fillet,
    ),
)

stg_q1 = ShortToGround(
    design,
    "stg_q1",
    {
        "pos_x": Q1.options.pos_x,
        "pos_y": Tee.options.shift_y + Tee.options.tee_width / 2 + Tee.options.ext_len,
        "orientation": "270",
    },
)
stg_r1 = ShortToGround(
    design,
    "stg_r1",
    {
        "pos_x": Q1.options.pos_x - (l_couple + fillet),
        "pos_y": port_L.options.pos_y
        - TL_gap
        - res_gap
        - (TL_width + res_width) / 2
        - grd_gap,
        "orientation": "180",
    },
)
start_jog = OrderedDict()
start_jog[0] = ["R", spacing]
R1 = RouteMeander(
    design,
    "R1",
    options=dict(
        total_length=R1_len - R_ext,
        fillet=fillet,
        hfss_wire_bonds=True,
        lead=dict(
            start_straight=l_couple + fillet,
            end_straight=0.1,
            start_jogged_extension=start_jog,
        ),
        trace_width=res_width,
        trace_gap=res_gap,
        meander=dict(spacing=spacing, asymmetry=0),
        pin_inputs=Dict(
            start_pin=Dict(component="stg_r1", pin="short"),
            end_pin=Dict(component="stg_q1", pin="short"),
        ),
    ),
)

gui.rebuild()
gui.autoscale()
# gui.zoom_on_components(["Q1"])
gui.screenshot()
```

## Charge line

```python
cl_vac, cl_grd, cl_ext = 0.020, 0.010, 0.150
cl_q1_gap = Rectangle(
    design,
    "cl_q1_gap",
    dict(
        pos_x=Q1.options.pos_x,
        pos_y=Q1.options.pos_y - Q1.options.pocket_height / 2 - cl_grd - cl_ext / 2,
        width=cpw_gap * 2 + cpw_width,
        height=cl_ext,
        subtract=True,
    ),
)
cl_q1_trace = Rectangle(
    design,
    "cl_q1_trace",
    dict(
        pos_x=Q1.options.pos_x,
        pos_y=Q1.options.pos_y - Q1.options.pocket_height / 2 - cl_grd - cl_ext / 2,
        width=cpw_width,
        height=cl_ext - cl_vac * 2,
    ),
)
cl_q1_stg = ShortToGround(
    design,
    "cl_q1_stg",
    dict(
        pos_x=Q1.options.pos_x,
        pos_y=Q1.options.pos_y
        - Q1.options.pocket_height / 2
        - cl_grd
        - cl_ext
        + cl_vac,
        orientation=90,
    ),
)
port_cl = LaunchpadWirebondDriven(
    design,
    "port_cl",
    options=dict(
        pad_width=0.5,
        pad_height=0.25,
        pad_gap=0.2,
        taper_height=0.5,
        pos_x=0,
        pos_y=-1,
        orientation=" 90",
        lead_length=0.05,
    ),
)
cl_q1_route = RoutePathfinder(
    design,
    "cl_q1_route",
    dict(
        trace_width=cpw_width,
        trace_gap=cpw_gap,
        fillet=0.100,
        hfss_wire_bonds=True,
        lead=dict(start_straight=0.100, end_straight=0.100),
        pin_inputs=Dict(
            start_pin=Dict(component="port_cl", pin="tie"),
            end_pin=Dict(component="cl_q1_stg", pin="short"),
        ),
    ),
)
gui.rebuild()
gui.autoscale()
gui.screenshot()
```

## Flux line

```python
q_loop_width, q_loop_height, q_loop_trace = 0.050, 0.010, 0.002
q_loop = RectangleHollow(
    design,
    "q_loop",
    dict(
        pos_x=Q1.options.pos_x
        - (q_loop_trace + q_loop_width + Q1.options.arm_width) / 2,
        pos_y=Q1.options.pos_y,
        width=q_loop_width + q_loop_trace,
        height=q_loop_height + 2 * q_loop_trace,
        inner=dict(
            width=q_loop_width,
            height=q_loop_height,
            offset_x=+q_loop_trace / 2,
            offset_y=0,
            orientation=0,
        ),
    ),
)

loop_H, loop_W, loop_wid = 0.050, 0.090, 0.005
fl_loop_stg_1 = ShortToGround(
    design,
    "fl_loop_stg_1",
    dict(
        pos_x=Q1.options.pos_x - Q1.options.pocket_width / 2,
        pos_y=Q1.options.pos_y - loop_H / 2,
        orientation=180,
    ),
)
fl_loop_stg_2 = ShortToGround(
    design,
    "fl_loop_stg_2",
    dict(
        pos_x=Q1.options.pos_x - Q1.options.pocket_width / 2,
        pos_y=Q1.options.pos_y + loop_H / 2,
        orientation=180,
    ),
)
fl_loop_route = RouteStraight(
    design,
    "fl_loop_route",
    dict(
        trace_width=loop_wid,
        trace_gap=0,
        fillet=0.010,
        hfss_wire_bonds=False,
        lead=dict(start_straight=loop_W, end_straight=loop_W),
        pin_inputs=Dict(
            start_pin=Dict(component="fl_loop_stg_1", pin="short"),
            end_pin=Dict(component="fl_loop_stg_2", pin="short"),
        ),
    ),
)
fl_q1_otg = ShortToGround(
    design,
    "fl_q1_otg",
    dict(
        pos_x=Q1.options.pos_x - Q1.options.pocket_width / 2,
        pos_y=Q1.options.pos_y - loop_H / 2,
        orientation=0,
    ),
)
port_fl = LaunchpadWirebondDriven(
    design,
    "port_fl",
    options=dict(
        pad_width=0.5,
        pad_height=0.25,
        pad_gap=0.2,
        taper_height=0.5,
        pos_x=-x_TL,
        pos_y=fl_loop_stg_1.options.pos_y,
        orientation="  0",
        lead_length=0.05,
    ),
)
fl_q1_route = RouteStraight(
    design,
    "fl_q1_route",
    dict(
        trace_width=cpw_width,
        trace_gap=cpw_gap,
        fillet=0.100,
        hfss_wire_bonds=True,
        lead=dict(start_straight=0.100, end_straight=0.100),
        pin_inputs=Dict(
            start_pin=Dict(component="port_fl", pin="tie"),
            end_pin=Dict(component="fl_q1_otg", pin="short"),
        ),
    ),
)
gui.rebuild()
gui.autoscale()
gui.screenshot()
```

# Simulation

```python
want_EC = 1.1
want_rf = 5.9
```

```python
want_q3d_EC = want_EC
```

## 1a. Cropped circuit with Q3D

```python
c2 = LOManalysis(design, "q3d")
q3d = c2.sim.renderer
# Manually set solution setups
q3d.start()
c2.sim.default_setup.update(
    dict(
        save_fields=True,
        percent_error=0.1,
        percent_refinement=30,
        max_passes=10,
        min_converged_passes=3,
    )
)
q3d.options.x_buffer_width_mm = 0.25
q3d.options.y_buffer_width_mm = 0.35
q3d.activate_ansys_design("1a_Cropped_qubit_a", "capacitive")
q3d.clean_active_design()
q3d.render_design(
    [
        "Q1",
        "cl_q1_gap",
        "cl_q1_trace",
        "fl_loop_route",
        "Tee",
    ],
    [],
)
q3d.modeler.mesh_length(
    "pad_and_lines",
    [
        "pad_bot_0_Q1",
        "pad_bot_1_Q1",
        "pad_top_0_Q1",
        "pad_top_1_Q1",
        "rectangle_cl_q1_trace",
        "tee_Tee1",
        "trace_fl_loop_route",
    ],
    MaxLength="0.03mm",
)
q3d.save_screenshot()
```

```python
c2.sim.capacitance_matrix, c2.sim.units = q3d.get_capacitance_matrix()
c2.sim.capacitance_all_passes, _ = q3d.get_capacitance_all_passes()

rawC_matrix = c2.sim.capacitance_matrix.to_numpy()

c2.sim.close()
c2.sim.capacitance_matrix
```

```python
M = np.eye(rawC_matrix.shape[0])
M[1, 2], M[2, 1], M[2, 2] = 1, 1, -1

C_matrix = np.linalg.inv(M) @ rawC_matrix @ np.linalg.inv(M)
np.set_printoptions(precision=4, suppress=True)
print(C_matrix)
```

```python
q3d_C = C_matrix[2, 2]
q3d_Cc = C_matrix[2, 4]
q3d_EC = zeq.invC2EC(np.linalg.inv(C_matrix)[2, 2])
print(
    "Result:",
    f"\nEC = {q3d_EC:.4f} GHz Cq = {q3d_C:.3f} fF, Cc = {q3d_Cc:.3f} fF",
    f"\nCc/Cq = { q3d_Cc / q3d_C:.4f}",
)
```

```python
print(f"proper param value: {pad_height * q3d_EC / want_q3d_EC:.3f}")
```

## 1b. Cropped circuit with eigenmode

```python
eig_cropped = EPRanalysis(design, "hfss")
cropped_hfss = eig_cropped.sim.renderer
cropped_hfss.options["x_buffer_width_mm"] = 0.4
cropped_hfss.options["y_buffer_width_mm"] = 0.4
cropped_hfss.start()
cropped_hfss.activate_ansys_design("1b_Cropped_qubit_eig_08", "eigenmode")
cropped_hfss.clean_active_design()
cropped_hfss.render_design(
    [
        "Q1",
        "cl_q1_gap",
        "cl_q1_trace",
        "fl_loop_route",
        "R1",
        "Tee",
    ],
    [],
)
cropped_hfss.modeler.mesh_length(
    "pad_and_lines",
    [
        "pad_bot_0_Q1",
        "pad_bot_1_Q1",
        "pad_top_0_Q1",
        "pad_top_1_Q1",
        "rectangle_cl_q1_trace",
        "trace_fl_loop_route",
        "trace_R1",
        "tee_Tee1",
    ],
    MaxLength="0.03mm",
)
cropped_hfss.modeler.mesh_length("JJ", ["JJ_rect_Lj_Q1_rect_jj"], MaxLength="0.01mm")

cropped_hfss.save_screenshot()
```

```python
hfss_rf = cropped_hfss.epr_get_frequencies()["Freq. (GHz)"][0]

eig_cropped.sim.close()
print(f"freq = {hfss_rf: .4f} Ghz")
print(f"proper_len = {R1_len * (hfss_rf / want_rf): .3f}")
```

```python
print(f"predict center_Lj: {zeq.Cfreq2L(q3d_C, hfss_rf):.3f}")
```

```python
%matplotlib inline
from zcu_tools.notebook.analysis.design.hfss import fit_hfss_anticross

result_path = fr"C:\Users\SQC\Desktop\Axel\Qubit-measure\result\{project_name}\data\LjSweep.csv"
fig, ax, center_Lj, hfss_rf, width = fit_hfss_anticross(result_path)

hfss_C = zeq.Lfreq2C(center_Lj, hfss_rf)
hfss_EC = zeq.C2EC(hfss_C)
center_EL = zeq.L2EL(center_Lj)
hfss_g = width / zeq.n_coeff(hfss_EC, center_EL)

ax.set_title(f"EC={hfss_EC:.4g} GHz, g={1e3 * hfss_g:.4g} MHz")

fig.savefig(result_path.replace("data", "image").replace(".csv", ".png"))

print(f"hfss_C = {hfss_C:.4g} fF")
print(f"hfss_EC = {hfss_EC:.4g} GHz")
print(f"g = {1e3 * hfss_g:.4g} MHz")
print(f"Frequency: {hfss_rf:.5g} GHz")
```

```python
q3d_hfss_ratio = q3d_EC / hfss_EC

want_q3d_EC = want_EC * q3d_hfss_ratio

print(f"q3d / hfss ratio: {q3d_hfss_ratio:.3f}")
print(f"proper q3d_EC: {want_q3d_EC: .3f} GHz")
```

## 2a. and 2b. Resonator linewidth with eigenmode and driven modal

```python
# Better run simulation on large-RAM PC
dm = ScatteringImpedanceSim(design, "hfss")
dm.renderer.start()
dm.renderer.activate_ansys_design(
    f"2b_resonator_linewidth_L={R1_len:.3f}mm_Lc={(l_couple - 1.5 * (res_width + res_gap * 2)):.3f}mm",
    "drivenmodal",
)
dm.renderer.options["x_buffer_width_mm"] = 0.35
dm.renderer.options["y_buffer_width_mm"] = 0.35
dm.renderer.clean_active_design()
port_list = [("port_L", "in", 50), ("port_R", "in", 50)]
dm.renderer.render_design(
    [
        "Q1",
        "port_L",
        "port_R",
        "TL",
        "Tee",
        "R1",
        "cl_q1_gap",
        "cl_q1_trace",
        "fl_loop_route",
    ],
    [],
    port_list=port_list,
)
dm.renderer.modeler.mesh_length(
    "port",
    ["Port_port_L_in", "Port_port_R_in", "launch_pad_port_L", "launch_pad_port_R"],
    MaxLength="0.1mm",
)
dm.renderer.modeler.mesh_length("JJ", ["JJ_rect_Lj_Q1_rect_jj"], MaxLength="0.01mm")
dm.renderer.modeler.mesh_length(
    "pad_and_lines",
    [
        "pad_bot_0_Q1",
        "pad_bot_1_Q1",
        "pad_top_0_Q1",
        "pad_top_1_Q1",
        "rectangle_cl_q1_trace",
        "trace_fl_loop_route",
        "trace_R1",
        "trace_TL",
        "tee_Tee1",
    ],
    MaxLength="0.03mm",
)
dm.save_screenshot()
```

```python
%load_ext autoreload
import pandas as pd

filepath = r"C:\Users\SQC\Desktop\Axel\HFSS\Fluxonium2D_R59_1Q\Project3_S_Sweep.csv"
data = pd.read_csv(filepath)
fpts = data["Freq [GHz]"].to_numpy()
signals = data["mag(S(LumpPort_port_R_in,LumpPort_port_L_in)) []"].to_numpy()

%autoreload 2
from zcu_tools.experiment.v2.onetone import FreqExperiment

FreqExperiment().analyze(result=(1e3 * fpts, signals), use_abcd=False)
```

## 4a. Flux line mutual inductance

```python
dm_fl = ScatteringImpedanceSim(design, "hfss")
dm_fl.renderer.start()
dm_fl.renderer.activate_ansys_design("4a_fl_mutual_dm", "drivenmodal")
dm_fl.renderer.options["x_buffer_width_mm"] = 0.4
dm_fl.renderer.options["y_buffer_width_mm"] = 0.4
# dm_fl.setup.update(
#     name = "setup", freq_ghz = 6.4, max_delta_s = 0.005, max_passes = 10, min_converged = 3, basis_order = 1
# )
# dm_fl.setup.sweep_setup.update(
#     name = "sweep_setup", start_ghz = 6.3, stop_ghz = 6.5, count = 401, type = "Fast"
# )
dm_fl.renderer.clean_active_design()
port_list = [("port_fl", "in", 50)]
dm_fl.renderer.render_design(
    [
        "Q1",
        "R1_ext_gap",
        "R1_ext_trace",
        "cl_q1_gap",
        "cl_q1_trace",
        "fl_q1_otg",
        "port_fl",
        "fl_q1_route",
        "fl_loop_stg_1",
        "fl_loop_stg_2",
        "fl_loop_route",
        "q_loop",
    ],
    [],
    port_list=port_list,
)
# dm.renderer.modeler.mesh_length('cpw_mesh', ['trace_R1', 'trace_TL'], MaxLength='0.007mm')
dm_fl.close()
```

## 4b. q3d mutual inductance

```python
M = LOManalysis(design, "q3d")
q3d = M.sim.renderer
# M.sim.default_setup.update(dict(save_fields=True, percent_error=0.1, percent_refinement=30, max_passes=25, min_converged_passes=5))
# Manually set up solution setups
q3d.start()
q3d.options.x_buffer_width_mm = 0.25
q3d.options.y_buffer_width_mm = 0.25
q3d.activate_ansys_design("4b_Cropped_qubit_L", "capacitive")
q3d.clean_active_design()
q3d.render_design(
    [
        "Q1",
        "Q1_top_pad",
        "Q1_bot_pad",
        "cl_q1_gap",
        "cl_q1_trace",
        "fl_loop_stg_1",
        "fl_loop_stg_2",
        "fl_loop_route",
        "R1_ext_gap",
        "R1_ext_trace",
        "q_loop",
    ],
    [],
)
# q3d.analyze_setup("Setup")
M.sim.close()
```

```python
# d,w,L: distance from flux line, loop_width, loop_length
# Ip: current applied for one sc flux quanta in loop
import scipy.constants as c
import numpy as np

d, w, L = 10e-6, 10e-6, 10e-6
Ip = (
    lambda d,
    w,
    L: f"{c.pi * c.h / (c.mu_0 * c.e * w) / (np.log((d + L) / d)) * 1e6:.2f} uA"
)
M = lambda d, w, L: f"{c.mu_0 / c.pi * w * np.log((d + L) / d) * 1e12:.3f} pH"
print(Ip(d, w, L))
print(M(d, w, L))
```
